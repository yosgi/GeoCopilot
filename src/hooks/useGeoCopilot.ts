import { useCallback, useState } from 'react';
import { SceneContextManager } from './useSceneContext';
import type { SceneContext } from './useSceneContext';
import { runEnhancedAgent } from '../agents/GeoCopilotAgent';
import * as Cesium from 'cesium';

interface GeoCopilotCommand {
  action: string;
  target?: string;
  parameters?: Record<string, unknown>;
  color?: string;
}

interface GeoCopilotState {
  commands: GeoCopilotCommand[];
  loading: boolean;
  error: string | null;
  lastResponse: string | null;
}

export const useGeoCopilot = (contextManager: SceneContextManager) => {
  const [state, setState] = useState<GeoCopilotState>({
    commands: [],
    loading: false,
    error: null,
    lastResponse: null
  });

  const run = useCallback(async (input: string) => {
    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      // get the current scene context
      const sceneContext = contextManager.getContext();
      
      console.log('Sending to AI:', { input, sceneContext });

      // call the enhanced AI agent
      const result = await runEnhancedAgent(input, sceneContext);
      
      console.log('AI Response:', result);

      if (result.success && result.commands.length > 0) {
        // execute the commands generated by the AI
        await executeCommands(result.commands, contextManager);
        
        setState(prev => ({
          ...prev,
          commands: result.commands,
          loading: false,
          lastResponse: result.explanation || 'Commands executed successfully'
        }));
      } else {
        setState(prev => ({
          ...prev,
          loading: false,
          error: result.explanation || 'No valid commands generated'
        }));
      }
    } catch (err) {
      console.error('GeoCopilot error:', err);
      setState(prev => ({
        ...prev,
        loading: false,
        error: err instanceof Error ? err.message : 'Unknown error occurred'
      }));
    }
  }, [contextManager]);

  const clearHistory = useCallback(() => {
    setState({
      commands: [],
      loading: false,
      error: null,
      lastResponse: null
    });
  }, []);

  return {
    ...state,
    run,
    clearHistory
  };
};

// execute the commands generated by the AI
async function executeCommands(commands: GeoCopilotCommand[], contextManager: SceneContextManager) {
  const viewer = contextManager.getViewer();
  if (!viewer) {
    throw new Error('Cesium viewer not available');
  }

  for (const command of commands) {
    try {
      await executeCommand(command, viewer, contextManager);
      
      // wait for a short time after each command to see the effect
      await new Promise(resolve => setTimeout(resolve, 300));
    } catch (error) {
      console.error(`Error executing command:`, command, error);
      // continue executing other commands, do not stop if one command fails
    }
  }
}

// execute a single command
async function executeCommand(
  command: GeoCopilotCommand, 
  viewer: Cesium.Viewer, 
  contextManager: SceneContextManager
) {
  const context = contextManager.getContext();

  switch (command.action) {
    case 'flyTo':
      await handleFlyToCommand(command, viewer, context);
      break;
      
    case 'showLayer':
    case 'hideLayer':
    case 'toggleLayer':
    case 'showOnlyLayer':
      await handleLayerCommand(command, viewer, context, contextManager);
      break;
      
    case 'highlight':
      await handleHighlightCommand(command);
      break;
      
    case 'setView':
      await handleSetViewCommand(command, viewer);
      break;
      
    case 'zoomTo':
      await handleZoomCommand(command, viewer);
      break;
      
    case 'measure':
      await handleMeasureCommand(command);
      break;
      
    case 'setTime':
      await handleTimeCommand(command, viewer);
      break;
      
    case 'reset':
      await handleResetCommand(viewer, context);
      break;
      
    default:
      console.warn(`Unknown command action: ${command.action}`);
  }
}

// 处理飞行命令
async function handleFlyToCommand(
  command: GeoCopilotCommand, 
  viewer: Cesium.Viewer, 
  context: SceneContext
) {
  let destination: Cesium.Cartesian3;

  if (command.target === 'main_building' || command.target === 'building') {
    // fly to the main building
    destination = Cesium.Cartesian3.fromDegrees(
      context.location.coordinates[0],
      context.location.coordinates[1],
      context.location.coordinates[2] + 100
    );
  } else if (command.parameters?.coordinates && Array.isArray(command.parameters.coordinates)) {
    // fly to the specified coordinates
    const [lng, lat, height] = command.parameters.coordinates as [number, number, number];
    destination = Cesium.Cartesian3.fromDegrees(lng, lat, height);
  } else {
    // default to the initial position
    destination = Cesium.Cartesian3.fromDegrees(
      -79.886626, 40.021649, 235.65
    );
  }

  await viewer.camera.flyTo({
    destination,
    duration: 2.0,
    orientation: {
      heading: 0,
      pitch: Cesium.Math.toRadians(-20),
      roll: 0
    }
  });
}

// handle the layer commands
async function handleLayerCommand(
  command: GeoCopilotCommand,
  viewer: Cesium.Viewer,
  context: SceneContext,
  contextManager: SceneContextManager
) {
  const layerName = command.target;
  if (!layerName) return;

  const primitives = viewer.scene.primitives;
  
  switch (command.action) {
    case 'showLayer':
      setLayerVisibility(primitives, layerName, true);
      break;
      
    case 'hideLayer':
      setLayerVisibility(primitives, layerName, false);
      break;
      
    case 'toggleLayer': {
      const currentLayer = context.layers.find(l => l.name === layerName);
      if (currentLayer) {
        setLayerVisibility(primitives, layerName, !currentLayer.visible);
      }
      break;
    }
      
    case 'showOnlyLayer':
      // hide all other layers, only show the specified layer
      context.layers.forEach(layer => {
        setLayerVisibility(primitives, layer.name, layer.name === layerName);
      });
      break;
  }

  // update the layer state in the context manager
  const updatedLayers = context.layers.map(layer => ({
    ...layer,
    visible: getLayerVisibility(primitives)
  }));
  contextManager.updateLayers(updatedLayers);
}

// set the layer visibility
function setLayerVisibility(primitives: Cesium.PrimitiveCollection, layerName: string, visible: boolean) {
  // For now, we'll toggle the first tileset found
  // In a real implementation, you'd want to track tileset-to-layer mapping
  for (let i = 0; i < primitives.length; i++) {
    const primitive = primitives.get(i);
    if (primitive instanceof Cesium.Cesium3DTileset) {
      primitive.show = visible;
      break;
    }
  }
}

// get the layer visibility
function getLayerVisibility(primitives: Cesium.PrimitiveCollection): boolean {
  // For now, return the visibility of the first tileset found
  // In a real implementation, you'd want to track tileset-to-layer mapping
  for (let i = 0; i < primitives.length; i++) {
    const primitive = primitives.get(i);
    if (primitive instanceof Cesium.Cesium3DTileset) {
      return primitive.show;
    }
  }
  return false;
}

// handle the highlight command
async function handleHighlightCommand(command: GeoCopilotCommand) {
  // here can implement the logic to highlight specific features or layers
  console.log(`Highlighting ${command.target} with color ${command.color || 'yellow'}`);
  // the actual implementation will depend on your needs
}

// handle the view setting command
async function handleSetViewCommand(command: GeoCopilotCommand, viewer: Cesium.Viewer) {
  if (command.parameters) {
    const { heading, pitch, roll } = command.parameters;
    viewer.camera.setView({
      orientation: {
        heading: heading && typeof heading === 'number' ? Cesium.Math.toRadians(heading) : viewer.camera.heading,
        pitch: pitch && typeof pitch === 'number' ? Cesium.Math.toRadians(pitch) : viewer.camera.pitch,
        roll: roll && typeof roll === 'number' ? Cesium.Math.toRadians(roll) : viewer.camera.roll
      }
    });
  }
}

// handle the zoom command
async function handleZoomCommand(command: GeoCopilotCommand, viewer: Cesium.Viewer) {
  if (command.parameters?.distance && typeof command.parameters.distance === 'number') {
    const currentPos = viewer.camera.positionWC;
    const cartographic = Cesium.Cartographic.fromCartesian(currentPos);
    
    await viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromRadians(
        cartographic.longitude,
        cartographic.latitude,
        command.parameters.distance
      ),
      duration: 1.5
    });
  }
}

// handle the measurement command
async function handleMeasureCommand(command: GeoCopilotCommand) {
  const measureType = command.parameters?.type || 'distance';
  console.log(`Starting ${measureType} measurement tool`);
  // here can start the corresponding measurement tool
}

// handle the time command
async function handleTimeCommand(command: GeoCopilotCommand, viewer: Cesium.Viewer) {
  if (command.parameters?.time && typeof command.parameters.time === 'string') {
    viewer.clock.currentTime = Cesium.JulianDate.fromIso8601(command.parameters.time);
  }
}

// handle the reset command
async function handleResetCommand(viewer: Cesium.Viewer, context: SceneContext) {
  await viewer.camera.flyTo({
    destination: Cesium.Cartesian3.fromDegrees(
      context.location.coordinates[0],
      context.location.coordinates[1],
      context.location.coordinates[2]
    ),
    orientation: {
      heading: 0,
      pitch: Cesium.Math.toRadians(-20),
      roll: 0
    },
    duration: 2.0
  });
}